# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name correlationCoefficient
#' @aliases correlationCoefficient,FastWilcoxTest-method
#' @rdname correlationCoefficient-methods
#' @docType methods
#' @description simply calculate the correlation between X and Y
#' @param X one numeric vector
#' @param Y the correlating vector
#' @title Calculate correlation over two double vectors
#' @export
correlationCoefficient <- function(X, Y) {
    .Call(`_FastWilcoxTest_correlationCoefficient`, X, Y)
}

#' @name CorMatrixIDS
#' @aliases CorMatrixIDS,FastWilcoxTest-method
#' @rdname CorMatrixIDS-methods
#' @docType methods
#' @description simply calculate the correlation between X and Y (slower than apply cor)
#' @param X the sparse matrix
#' @param CMP the vector to correlate every column of the matrix to
#' @param ids the rows of the matrix to correlate to
#' @title Calculate correlation over two double vectors
#' @export
CorMatrixIDS <- function(X, CMP, ids) {
    .Call(`_FastWilcoxTest_CorMatrixIDS`, X, CMP, ids)
}

#' @name CorMatrix
#' @aliases CorMatrix,FastWilcoxTest-method
#' @rdname CorMatrix-methods
#' @docType methods
#' @description simply calculate the correlation between X and Y
#' approximately 3x faster than an apply using the R cor function on sparse data
#' @param X the sparse matrix
#' @param CMP the vector to correlate every column of the matrix to
#' @title Calculate correlation over two double vectors
#' @export
CorMatrix <- function(X, CMP) {
    .Call(`_FastWilcoxTest_CorMatrix`, X, CMP)
}

#' @name CorNormalMatrix
#' @aliases CorNormalMatrixIDS,FastWilcoxTest-method
#' @rdname CorNormalMatrixIDS-methods
#' @docType methods
#' @description simply calculate the correlation between X and Y 
#' @param X the normal matrix
#' @param CMP the vector to correlate every column of the matrix to
#' @title Calculate correlation over two double vectors
#' @export
CorNormalMatrix <- function(X, CMP) {
    .Call(`_FastWilcoxTest_CorNormalMatrix`, X, CMP)
}

#' @name rollSum
#' @aliases rollSum,FastWilcoxTest-method
#' @rdname rollSum-methods
#' @docType methods
#' @description calculate a rolling sum of the rows
#' @param X the sparse matrix
#' @param n the size of the rolling window
#' @title rolling sum over sparse matrix
#' @export
rollSum <- function(X, n) {
    .Call(`_FastWilcoxTest_rollSum`, X, n)
}

#' @name LinLang
#' @aliases LinLang,FastWilcoxTest-method
#' @rdname LinLang-methods
#' @docType methods
#' @description Identify genes slowly rising above the detection limit
#' @param X the sparse Matrix (row = genes, col = cells)
#' @param Grouping a numeric vector of group IDs
#' @param nGroup the number of groups
#' @param minPct ignore genes with less than a fraction of 0.1 (default) of the cells expressing them
#' @param display_progress show a progress bar (TRUE)
#' @title LinLang test for rise above the detection limit
#' @export
LinLang <- function(X, Grouping, nGroup, minPct = 0.1, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_LinLang`, X, Grouping, nGroup, minPct, display_progress)
}

#' @name LogNorm
#' @aliases LogNorm,FastWilcoxTest-method
#' @rdname LogNorm-methods
#' @docType methods
#' @description Normalize the single cell expression read counts values to a scale_factor.
#' @param X the sparse Matrix (row = genes, col = cells)
#' @param scale_factor the total read count to reach
#' @param display_progress show a progress bar (TRUE)
#' @title UMI normalize a single cell expression matrix
#' @export
LogNorm <- function(data, scale_factor, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_LogNorm`, data, scale_factor, display_progress)
}

#' @name NormalizeCells
#' @aliases NormalizeCells,FastWilcoxTest-method
#' @rdname NormalizeCells-methods
#' @docType methods
#' @description Normalize the single cell expression values to a total of nUMI reads.
#' @param X the sparse Matrix (row = genes, col = cells)
#' @param nUMI aim to normalize each cell to (cells expressing less are set to 0)
#' @param display_progress show a progress bar (TRUE)
#' @title UMI normalize a single cell expression matrix
#' @export
NormalizeCells <- function(X, nUMI, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_NormalizeCells`, X, nUMI, display_progress)
}

#' @name NormalizeSamples
#' @aliases NormalizeSamples,FastWilcoxTest-method
#' @rdname NormalizeSamples-methods
#' @docType methods
#' @description Normalize the NGS expression values by log re-scaling.
#' @param data the sparse Matrix (row = genes, col = cells)
#' @param scaleFactor the geometric mean of the data (use DESeq2 to get these)
#' @param display_progress show a progress bar (TRUE)
#' @title rescale a matrix using scaleFactor per column
#' @export
NormalizeSamples <- function(X, scaleFactor, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_NormalizeSamples`, X, scaleFactor, display_progress)
}

#' @title logFC calculates a log fold change between the two input vectors
#' @aliases logFC,FastWilcoxTest-method
#' @rdname logFC
#' @description a simple replacement of wilcox.test returning less information but >10x faster
#' @param A one numeric vector of log data
#' @param B the other log vector
#' @return a double fold change
#' @export
logFC <- function(A, B) {
    .Call(`_FastWilcoxTest_logFC`, A, B)
}

minusOne <- function(X) {
    .Call(`_FastWilcoxTest_minusOne`, X)
}

plusOne <- function(X) {
    .Call(`_FastWilcoxTest_plusOne`, X)
}

#' @title cppWilcoxTest runs wilcox test comparing x and y
#' @aliases cppWilcoxTest,cppWilcoxTest-method
#' @rdname cppWilcoxTest
#' @description a simple replacement of wilcox.test returning less information but >10x faster
#' @param x the interesting information
#' @param y the background information
#' @param type the test type (greater=0,less=1,twoSided=2,U=3,Abslog10greater=4,log10less=5,abslog10twoSided=6,Q=7)
#' @return a double vector with 2 entries : Rank sum and p.value,
#' @export
cppWilcoxTest <- function(x, y, type) {
    .Call(`_FastWilcoxTest_cppWilcoxTest`, x, y, type)
}

#' @title StatTest runs wilcox test on the columns of the sparse matrix
#' @aliases StatTest,FastWilcoxTest-method
#' @rdname StatTest
#' @description This test implements the Seurat FindMarkers( test.use == "wilcox" ) function
#' in the greatest possible way, but using Rcpp instead of R. So far I could get a ~10x speed improvement.
#' @param X the sparse matrix (tests are applied to columns!)
#' @param interest row IDs for the group of interest
#' @param background row IDS for the background
#' @param logFCcut data is meant to be log() transformed and only columns passing a logFCcut of (default 1) are tested
#' @param minPct only test genes that are detected in a minimum fraction of
#' minPct cells in either of the two populations. Meant to speed up the function
#' by not testing genes that are very infrequently expressed. Default is 0.1
#' @param onlyPos check only higher expression (default FALSE)
#' @return a matrix with tested column ids, logFC and p.value
#' @export
StatTest <- function(X, interest, background, logFCcut = 1.0, minPct = 0.1, onlyPos = FALSE) {
    .Call(`_FastWilcoxTest_StatTest`, X, interest, background, logFCcut, minPct, onlyPos)
}

#' @name ZScore
#' @aliases ZScore,FastWilcoxTest-method
#' @rdname ZScore-methods
#' @docType methods
#' @description A specific z. score method that converts the data to 10 +-1 instead of 0+-1
#' in order to keep the not expressed clearly separate from the real data.
#' @param data the sparse Matrix
#' @param display_progress show a progress bar (TRUE)
#' @title Calculate z score for a sparse matrix
#' @export
ZScore <- function(data, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_ZScore`, data, display_progress)
}

#' @name MEAN_STD
#' @aliases MEAN_STD,FastWilcoxTest-method
#' @rdname MEAN_STD-methods
#' @docType methods
#' @description A specific z. score method that converts the data to 10 +-1 instead of 0+-1
#' in order to keep the not expressed clearly separate from the real data.
#' @param data a spare matrix
#' @title Calculate mean and std of >0 values in a sparse matrix
#' @export
MEAN_STD <- function(data) {
    .Call(`_FastWilcoxTest_MEAN_STD`, data)
}

#' @name SQRT
#' @aliases SQRT,FastWilcoxTest-method
#' @rdname SQRT-methods
#' @docType methods
#' @description A specific z. score method that converts the data to 10 +-1 instead of 0+-1
#' in order to keep the not expressed clearly separate from the real data.
#' @param data a vector
#' @title Calculate z score for a sparse matrix
#' @export
SQRT <- function(data) {
    .Call(`_FastWilcoxTest_SQRT`, data)
}

#' @name collapse
#' @aliases collapse,FastWilcoxTest-method
#' @rdname collapse-methods
#' @docType methods
#' @description sums up the values for each ids type
#' @param X the sparse matrix
#' @param ids group ids (int vector from 1 10 maxgroup for each column)
#' @param type ( 0: logAdd (defunct); 1 : simple addition; 2: log Add -1 (defunct) )
#' @title Calculate correlation over two double vectors
#' @export
collapse <- function(X, ids, type) {
    .Call(`_FastWilcoxTest_collapse`, X, ids, type)
}

#' Calculate the euclidian distance between consecutive points
#' Can also produce the integral values of the distance.
#' @name euclidian_distances
#' @aliases euclidian_distances,FastWilcoxTest-method
#' @rdname euclidian_distances-methods
#' @docType methods
#' @description calculates the (2D) euclidian distance for a set of x and y values
#' @param X one ORDERED numeric vector
#' @param Y the other vector
#' @param sum create a total sum of these values (integral) default = FALSE
#' @title Calculate  over two double vectors
#' @export
euclidian_distances <- function(X, Y, sum = FALSE) {
    .Call(`_FastWilcoxTest_euclidian_distances`, X, Y, sum)
}

#' Calculate the euclidian distance between consecutive points
#' Can also produce the integral values of the distance.
#' @name euclidian_distances3d
#' @aliases euclidian_distances3d,FastWilcoxTest-method
#' @rdname euclidian_distances3d-methods
#' @docType methods
#' @description calculates the (3D) euclidian distance for a set of x and y values
#' @param X one ORDERED numeric vector
#' @param Y the other vector
#' @param Z the thrid dimension
#' @param sum create a total sum of these values (integral) default = FALSE
#' @title Calculate  over two double vectors
#' @export
euclidian_distances3d <- function(X, Y, Z, sum = FALSE) {
    .Call(`_FastWilcoxTest_euclidian_distances3d`, X, Y, Z, sum)
}

#' use the eucledian distance between one cell and all cells to find the order in the data
#' @name eDist3d
#' @aliases eDist3d,FastWilcoxTest-method
#' @rdname eDist3d-methods
#' @docType methods
#' @description calculates the (3D) euclidian distance for a set of x and y values
#' @param X one numeric vector
#' @param Y the other vector
#' @param Z the thrid dimension
#' @param id which id to start from
#' @title find the euclidian order in a 3D vector
#' @export
eDist3d <- function(X, Y, Z, id) {
    .Call(`_FastWilcoxTest_eDist3d`, X, Y, Z, id)
}

toColNums <- function(data) {
    .Call(`_FastWilcoxTest_toColNums`, data)
}

#' @title ColNotZero returns the amount of not zero values in each column
#' @aliases ColNotZero,FastWilcoxTest-method
#' @rdname ColNotZero
#' @description a c++ implementation of apply(x,2,function(d) {length(which(d!=0))} )
#' @param data a sparse matrix
#' @return a vector with nGene information
#' @export
ColNotZero <- function(data) {
    .Call(`_FastWilcoxTest_ColNotZero`, data)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_FastWilcoxTest_RcppExport_registerCCallable', PACKAGE = 'FastWilcoxTest')
})
