# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name correlationCoefficient
#' @aliases correlationCoefficient,FastWilcoxTest-method
#' @rdname correlationCoefficient-methods
#' @docType methods
#' @description simply calculate the correlation between X and Y
#' @param X one numeric vector
#' @param Y the correlating vector
#' @title Calculate correlation over two double vectors
#' @export
correlationCoefficient <- function(X, Y) {
    .Call(`_FastWilcoxTest_correlationCoefficient`, X, Y)
}

#' @name CorMatrixIDS
#' @aliases CorMatrixIDS,FastWilcoxTest-method
#' @rdname CorMatrixIDS-methods
#' @docType methods
#' @description simply calculate the correlation between X and Y (slower than apply cor)
#' @param X the sparse matrix
#' @param CMP the vector to correlate every column of the matrix to
#' @param ids the rows of the matrix to correlate to
#' @title Calculate correlation over two double vectors
#' @export
CorMatrixIDS <- function(X, CMP, ids) {
    .Call(`_FastWilcoxTest_CorMatrixIDS`, X, CMP, ids)
}

#' @name CorMatrixIDS_N
#' @aliases CorMatrixIDS_N,FastWilcoxTest-method
#' @rdname CorMatrixIDS_N-methods
#' @docType methods
#' @description simply calculate the correlation between X and Y (slower than apply cor)
#' @param X the sparse matrix
#' @param CMP the vector to correlate every column of the matrix to
#' @param ids the rows of the matrix to correlate to
#' @title Calculate correlation over two double vectors
#' @returns a matrix of Rho and n (cells where both values where > 0)
#' @export
CorMatrixIDS_N <- function(X, CMP, ids) {
    .Call(`_FastWilcoxTest_CorMatrixIDS_N`, X, CMP, ids)
}

#' @name CorMatrix
#' @aliases CorMatrix,FastWilcoxTest-method
#' @rdname CorMatrix-methods
#' @docType methods
#' @description simply calculate the correlation between X and Y
#' approximately 3x faster than an apply using the R cor function on sparse data
#' @param X the sparse matrix
#' @param CMP the vector to correlate every column of the matrix to
#' @title Calculate correlation over two double vectors
#' @export
CorMatrix <- function(X, CMP) {
    .Call(`_FastWilcoxTest_CorMatrix`, X, CMP)
}

#' @name CorMatrix_N
#' @aliases CorMatrix_N,FastWilcoxTest-method
#' @rdname CorMatrix_N-methods
#' @docType methods
#' @description simply calculate the correlation between X and Y
#' approximately 3x faster than an apply using the R cor function on sparse data
#' @param X the sparse matrix
#' @param CMP the vector to correlate every column of the matrix to
#' @title Calculate correlation over two double vectors
#' @returns a matrix of Rho and n (cells where both values where > 0)
#' @export
CorMatrix_N <- function(X, CMP) {
    .Call(`_FastWilcoxTest_CorMatrix_N`, X, CMP)
}

#' @name CorNormalMatrix
#' @aliases CorNormalMatrixIDS,FastWilcoxTest-method
#' @rdname CorNormalMatrixIDS-methods
#' @docType methods
#' @description simply calculate the correlation between X and Y 
#' @param X the normal matrix
#' @param CMP the vector to correlate every column of the matrix to
#' @title Calculate correlation over two double vectors
#' @export
CorNormalMatrix <- function(X, CMP) {
    .Call(`_FastWilcoxTest_CorNormalMatrix`, X, CMP)
}

#' Calculatethe rolling sum for a max distance from the start
#' The location of each row is taken from the S (Start) vector
#' In R the colnames need to be set to the input colnames whereas the start positions need to be set to chrXY : S[i] - (S[i]+n)
#' @name rollSumStart
#' @aliases rollSumStart,FastWilcoxTest-method
#' @rdname rollSumStartStart-methods
#' @docType methods
#' @description calculate a rolling sum of the rows
#' @param X the sparse matrix
#' @param n the length of the rolling window
#' @param S the start positions of each X row
#' @title rolling sum over sparse matrix
#' @export
rollSumStart <- function(X, n, S) {
    .Call(`_FastWilcoxTest_rollSumStart`, X, n, S)
}

#' @name LinLang
#' @aliases LinLang,FastWilcoxTest-method
#' @rdname LinLang-methods
#' @docType methods
#' @description Identify genes slowly rising above the detection limit
#' @param X the sparse Matrix (row = genes, col = cells)
#' @param Grouping a numeric vector of group IDs
#' @param nGroup the number of groups
#' @param minPct ignore genes with less than a fraction of 0.1 (default) of the cells expressing them
#' @param display_progress show a progress bar (TRUE)
#' @title LinLang test for rise above the detection limit
#' @export
LinLang <- function(X, Grouping, nGroup, minPct = 0.1, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_LinLang`, X, Grouping, nGroup, minPct, display_progress)
}

#' @name LogNorm
#' @aliases LogNorm,FastWilcoxTest-method
#' @rdname LogNorm-methods
#' @docType methods
#' @description Normalize the single cell expression read counts values to a scale_factor.
#' @param X the sparse Matrix (row = genes, col = cells)
#' @param scale_factor the total read count to reach
#' @param display_progress show a progress bar (TRUE)
#' @title UMI normalize a single cell expression matrix
#' @export
LogNorm <- function(data, scale_factor, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_LogNorm`, data, scale_factor, display_progress)
}

#' @name NormalizeCells
#' @aliases NormalizeCells,FastWilcoxTest-method
#' @rdname NormalizeCells-methods
#' @docType methods
#' @description Normalize the single cell expression values to a total of nUMI reads.
#' @param X the sparse Matrix (row = genes, col = cells)
#' @param nUMI aim to normalize each cell to (cells expressing less are set to 0)
#' @param display_progress show a progress bar (TRUE)
#' @title UMI normalize a single cell expression matrix
#' @export
NormalizeCells <- function(X, nUMI, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_NormalizeCells`, X, nUMI, display_progress)
}

#' @name NormalizeSamples
#' @aliases NormalizeSamples,FastWilcoxTest-method
#' @rdname NormalizeSamples-methods
#' @docType methods
#' @description Normalize the NGS expression values by log re-scaling.
#' @param data the sparse Matrix (row = genes, col = cells)
#' @param scaleFactor the geometric mean of the data (use DESeq2 to get these)
#' @param display_progress show a progress bar (TRUE)
#' @title rescale a matrix using scaleFactor per column
#' @export
NormalizeSamples <- function(X, scaleFactor, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_NormalizeSamples`, X, scaleFactor, display_progress)
}

#' @title reshuffle data based on a sparse matrix assuming max double the amount of entries not being zero
#' @aliases ShuffleMatrix,FastWilcoxTest-method
#' @rdname ShuffleMatrix
#' @description replacing the synthetic1 function of RFclust.SGE package 
#' @param X the sparse matrix (tests are applied to columns!)
#' @param maxCols the amount of random columns to send back (default 50)
#' @return a matrix with x, j and i avalues to be put into a new sparse matrix
#' @export
ShuffleMatrix <- function(X, maxCols = 50L) {
    .Call(`_FastWilcoxTest_ShuffleMatrix`, X, maxCols)
}

#' @title logFC calculates a log fold change between the two input vectors
#' @aliases logFC,FastWilcoxTest-method
#' @rdname logFC
#' @description a simple replacement of wilcox.test returning less information but >10x faster
#' @param A one numeric vector of log data
#' @param B the other log vector
#' @return a double fold change
#' @export
logFC <- function(A, B) {
    .Call(`_FastWilcoxTest_logFC`, A, B)
}

minusOne <- function(X) {
    .Call(`_FastWilcoxTest_minusOne`, X)
}

plusOne <- function(X) {
    .Call(`_FastWilcoxTest_plusOne`, X)
}

#' @title cppWilcoxTest runs wilcox test comparing x and y
#' @aliases cppWilcoxTest,cppWilcoxTest-method
#' @rdname cppWilcoxTest
#' @description a simple replacement of wilcox.test returning less information but >10x faster
#' @param x the interesting information
#' @param y the background information
#' @param type the test type (greater=0,less=1,twoSided=2,U=3,Abslog10greater=4,log10less=5,abslog10twoSided=6,Q=7)
#' @return a double vector with 2 entries : Rank sum and p.value,
#' @export
cppWilcoxTest <- function(x, y, type) {
    .Call(`_FastWilcoxTest_cppWilcoxTest`, x, y, type)
}

#' @title StatTest runs wilcox test on the columns of the sparse matrix
#' @aliases StatTest,FastWilcoxTest-method
#' @rdname StatTest
#' @description This test implements the Seurat FindMarkers( test.use == "wilcox" ) function
#' in the greatest possible way, but using Rcpp instead of R. So far I could get a ~10x speed improvement.
#' @param X the sparse matrix (tests are applied to columns!)
#' @param interest row IDs for the group of interest
#' @param background row IDS for the background
#' @param logFCcut data is meant to be log() transformed and only columns passing a logFCcut of (default 1) are tested
#' @param minPct only test genes that are detected in a minimum fraction of
#' minPct cells in either of the two populations. Meant to speed up the function
#' by not testing genes that are very infrequently expressed. Default is 0.1
#' @param onlyPos check only higher expression (default FALSE)
#' @return a matrix with tested column ids, logFC and p.value
#' @export
StatTest <- function(X, interest, background, logFCcut = 1.0, minPct = 0.1, onlyPos = FALSE) {
    .Call(`_FastWilcoxTest_StatTest`, X, interest, background, logFCcut, minPct, onlyPos)
}

#' @name ZScore
#' @aliases ZScore,FastWilcoxTest-method
#' @rdname ZScore-methods
#' @docType methods
#' @description A specific z. score method that converts the data to 10 +-1 instead of 0+-1
#' in order to keep the not expressed clearly separate from the real data.
#' @param data the sparse Matrix
#' @param display_progress show a progress bar (TRUE)
#' @title Calculate z score for a sparse matrix
#' @export
ZScore <- function(data, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_ZScore`, data, display_progress)
}

#' @name ZScoreAll
#' @aliases ZScoreAll,FastWilcoxTest-method
#' @rdname ZScoreAll-methods
#' @docType methods
#' @description A sparse matrix z. score function returning the same as a normal one
#' @param data the sparse Matrix
#' @param display_progress show a progress bar (TRUE)
#' @title Calculate z score for a sparse matrix
#' @export
ZScoreAll <- function(data, display_progress = TRUE) {
    .Call(`_FastWilcoxTest_ZScoreAll`, data, display_progress)
}

#' @name MEAN_STD
#' @aliases MEAN_STD,FastWilcoxTest-method
#' @rdname MEAN_STD-methods
#' @docType methods
#' @description A specific z. score method that converts the data to 10 +-1 instead of 0+-1
#' in order to keep the not expressed clearly separate from the real data.
#' @param data a spare matrix
#' @title Calculate mean and std of >0 values in a sparse matrix
#' @export
MEAN_STD <- function(data) {
    .Call(`_FastWilcoxTest_MEAN_STD`, data)
}

#' @name SQRT
#' @aliases SQRT,FastWilcoxTest-method
#' @rdname SQRT-methods
#' @docType methods
#' @description A specific z. score method that converts the data to 10 +-1 instead of 0+-1
#' in order to keep the not expressed clearly separate from the real data.
#' @param data a vector
#' @title Calculate z score for a sparse matrix
#' @export
SQRT <- function(data) {
    .Call(`_FastWilcoxTest_SQRT`, data)
}

#' @name collapse
#' @aliases collapse,FastWilcoxTest-method
#' @rdname collapse-methods
#' @docType methods
#' @description sums up the values for each ids type
#' @param X the sparse matrix
#' @param ids group ids (int vector from 1 10 maxgroup for each column)
#' @param type ( 0: logAdd (defunct); 1 : simple addition; 2: mean )
#' @title collapse the data collumns based on the ids info
#' @export
collapse <- function(X, ids, type) {
    .Call(`_FastWilcoxTest_collapse`, X, ids, type)
}

#' @name entropy
#' @aliases entropy,cellexalvrR-method
#' @rdname entropy-methods
#' @docType methods
#' @description calculate the entropy of one double vector. Each number is a new group.
#' @param X a double vector of group ids
#' @title description of function entrop
#' @export 
entropy <- function(X) {
    .Call(`_FastWilcoxTest_entropy`, X)
}

#' @name SphericEntropy
#' @aliases SphericEntropy,cellexalvrR-method
#' @rdname SphericEntropy-methods
#' @docType methods
#' @description Calculate a per cell entropy for a vector of radius cut-offs.
#' @param X1 a double vector of dim1
#' @param X2 a double vector of dim2
#' @param X3 a double vector of dim3
#' @param gvect a double vector of the output group
#' @param radii a double vector of the euclidian max distances (radius) to be checked
#' @title description of function entrop
#' @export 
SphericEntropy <- function(X1, X2, X3, gvect, radii) {
    .Call(`_FastWilcoxTest_SphericEntropy`, X1, X2, X3, gvect, radii)
}

#' Calculate the euclidian distance between consecutive points
#' Can also produce the integral values of the distance.
#' @name euclidian_distances
#' @aliases euclidian_distances,FastWilcoxTest-method
#' @rdname euclidian_distances-methods
#' @docType methods
#' @description calculates the (2D) euclidian distance for a set of x and y values
#' @param X one ORDERED numeric vector
#' @param Y the other vector
#' @param sum create a total sum of these values (integral) default = FALSE
#' @title Calculate  over two double vectors
#' @export
euclidian_distances <- function(X, Y, sum = FALSE) {
    .Call(`_FastWilcoxTest_euclidian_distances`, X, Y, sum)
}

#' Calculate the euclidian distance between consecutive points
#' Can also produce the integral values of the distance.
#' @name euclidian_distances3d
#' @aliases euclidian_distances3d,FastWilcoxTest-method
#' @rdname euclidian_distances3d-methods
#' @docType methods
#' @description calculates the (3D) euclidian distance for a set of x and y values
#' @param X one ORDERED numeric vector
#' @param Y the other vector
#' @param Z the thrid dimension
#' @param sum create a total sum of these values (integral) default = FALSE
#' @title Calculate  over two double vectors
#' @export
euclidian_distances3d <- function(X, Y, Z, sum = FALSE) {
    .Call(`_FastWilcoxTest_euclidian_distances3d`, X, Y, Z, sum)
}

#' use the eucledian distance between one cell and all cells to find the order in the data
#' @name eDist3d
#' @aliases eDist3d,FastWilcoxTest-method
#' @rdname eDist3d-methods
#' @docType methods
#' @description calculates the (3D) euclidian distance for a set of x and y values
#' @param X one numeric vector
#' @param Y the other vector
#' @param Z the thrid dimension
#' @param id which id to start from
#' @title find the euclidian order in a 3D vector
#' @export
eDist3d <- function(X, Y, Z, id) {
    .Call(`_FastWilcoxTest_eDist3d`, X, Y, Z, id)
}

#' @title extract proximity for the ranger results
#' copied from https://github.com/imbs-hl/ranger/issues/234
#' @aliases extract_proximity_oob,FastWilcoxTest-method
#' @rdname extract_proximity_oob
#' @description calculate the proximity matrix
#' @param pred the predictions created from a predict(rangerRF, data, type = "terminalNodes")$predictions
#' @param prox an empty matrix with dim(pred) dimensions
#' @param inbag the inbag information from the ranger prediction run (rangerRF$inbag.counts)
#' @return prox with correct values
#' @export
extract_proximity_oob <- function(pred, prox, inbag) {
    .Call(`_FastWilcoxTest_extract_proximity_oob`, pred, prox, inbag)
}

#' @name rollSum
#' @aliases rollSum,FastWilcoxTest-method
#' @rdname rollSum-methods
#' @docType methods
#' @description calculate a rolling sum of the rows
#' @param X the sparse matrix
#' @param n the size of the rolling window
#' @title rolling sum over sparse matrix
#' @export
rollSum <- function(X, n) {
    .Call(`_FastWilcoxTest_rollSum`, X, n)
}

#' The numbers start at the first row and end at the last row having a full sized widow
#' 
#' @name rollAreaSum
#' @aliases rollAreaSum,FastWilcoxTest-method
#' @rdname rollAreaSum-methods
#' @docType methods
#' @description calculate a rolling sum of the rows
#' @param X the sparse matrix
#' @param size the size of the rolling window
#' @param location the location for every row in the matrix
#' @param funcID two functions : 1 == sum; 2 == mean
#' @title rolling sum over sparse matrix
#' @export
rollAreaSum <- function(X, location, funcID, size) {
    .Call(`_FastWilcoxTest_rollAreaSum`, X, location, funcID, size)
}

#' @title sparse2SQLite_text_file creates a simple text file from the matrix contents
#' @aliases sparse2SQLite_text_file,FastWilcoxTest-method
#' @rdname sparse2SQLite_text_file
#' @description circumvent the memory expenses during RSQlite database creation (melting the whole matrix)
#' @param data a sparse matrix
#' @return a vector with nGene information
#' @export
sparse2SQLite_text_file <- function(data, file, sep = ' ') {
    invisible(.Call(`_FastWilcoxTest_sparse2SQLite_text_file`, data, file, sep))
}

#' @title toColNums returns a vector with column IDs
#' @aliases toColNums,FastWilcoxTest-method
#' @rdname toColNums
#' @description using c++ to get the column IDS mapping to the @x values.
#' @param data a sparse matrix
#' @return a vector with nGene information
#' @export
#' @return a vector of col ids in the order of the @x vector
toColNums <- function(data) {
    .Call(`_FastWilcoxTest_toColNums`, data)
}

#' @title ColNotZero returns the amount of not zero values in each column
#' @aliases ColNotZero,FastWilcoxTest-method
#' @rdname ColNotZero
#' @description a c++ implementation of apply(x,2,function(d) {length(which(d!=0))} )
#' @param data a sparse matrix
#' @return a vector with nGene information
#' @export
ColNotZero <- function(data) {
    .Call(`_FastWilcoxTest_ColNotZero`, data)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_FastWilcoxTest_RcppExport_registerCCallable', PACKAGE = 'FastWilcoxTest')
})
